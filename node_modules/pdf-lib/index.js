const placeholderStart = '%%DYNAMIC_CONTENT_START%%\n';
const placeholderEnd = '\n%%DYNAMIC_CONTENT_END%%';

class EmbeddedFont {
  constructor(name) {
    this.name = name;
  }
}

class PDFPage {
  constructor(doc) {
    this.doc = doc;
  }

  drawText(text, options = {}) {
    const {
      x = 0,
      y = 0,
      size = 12,
      font = this.doc.defaultFont,
      color = { r: 0, g: 0, b: 0 },
    } = options;

    const safeText = this.doc.escapeText(text);
    const fontRef = font instanceof EmbeddedFont ? font.name : this.doc.defaultFont.name;
    const colorCommand = `${color.r.toFixed(4)} ${color.g.toFixed(4)} ${color.b.toFixed(4)} rg`;
    const matrixCommand = `1 0 0 1 ${x.toFixed(2)} ${y.toFixed(2)} Tm`;
    const command = [
      'BT',
      `${fontRef} ${size.toFixed(2)} Tf`,
      colorCommand,
      matrixCommand,
      `(${safeText}) Tj`,
      'ET',
    ].join('\n');

    this.doc.dynamicBlocks.push(command);
  }

  getSize() {
    return { ...this.doc.pageSize };
  }
}

class PDFDocument {
  constructor(templateBuffer) {
    this.templateBuffer = templateBuffer;
    this.templateString = templateBuffer.toString('binary');
    this.placeholderStartIndex = this.templateString.indexOf(placeholderStart);
    this.placeholderEndIndex = this.templateString.indexOf(placeholderEnd, this.placeholderStartIndex);

    if (this.placeholderStartIndex === -1 || this.placeholderEndIndex === -1) {
      throw new Error('Template is missing dynamic content markers.');
    }

    this.placeholderContentStart = this.placeholderStartIndex + placeholderStart.length;
    this.placeholderContentEnd = this.placeholderEndIndex;
    this.placeholderLength = this.placeholderContentEnd - this.placeholderContentStart;

    this.dynamicBlocks = [];
    this.defaultFont = new EmbeddedFont('/F1');
    this.fonts = {
      Helvetica: new EmbeddedFont('/F1'),
      'Helvetica-Bold': new EmbeddedFont('/F2'),
    };

    const mediaBoxMatch = this.templateString.match(/\/MediaBox \[0 0 ([0-9.]+) ([0-9.]+)\]/);
    if (mediaBoxMatch) {
      this.pageSize = {
        width: parseFloat(mediaBoxMatch[1]),
        height: parseFloat(mediaBoxMatch[2]),
      };
    } else {
      this.pageSize = { width: 595.28, height: 841.89 };
    }
  }

  static async load(buffer) {
    if (!Buffer.isBuffer(buffer)) {
      throw new TypeError('PDFDocument.load expects a Buffer');
    }
    return new PDFDocument(buffer);
  }

  async embedFont(fontName) {
    if (!Object.prototype.hasOwnProperty.call(this.fonts, fontName)) {
      throw new Error(`Font ${fontName} is not available in the template.`);
    }
    return this.fonts[fontName];
  }

  getPages() {
    return [new PDFPage(this)];
  }

  escapeText(value) {
    if (value === null || value === undefined) {
      return '';
    }

    return String(value)
      .replace(/\\/g, '\\\\')
      .replace(/\(/g, '\\(')
      .replace(/\)/g, '\\)');
  }

  setTitle() { /* no-op for template-based PDFs */ }

  setAuthor() { /* no-op */ }

  setCreator() { /* no-op */ }

  async save() {
    const dynamicContent = this.dynamicBlocks.join('\n');
    if (dynamicContent.length > this.placeholderLength) {
      throw new Error('Dynamic content exceeds reserved space in the template.');
    }

    const paddedContent = `${dynamicContent}${' '.repeat(this.placeholderLength - dynamicContent.length)}`;
    const prefix = this.templateString.slice(0, this.placeholderContentStart);
    const suffix = this.templateString.slice(this.placeholderContentEnd);
    const updated = `${prefix}${paddedContent}${suffix}`;

    return Buffer.from(updated, 'binary');
  }
}

const StandardFonts = {
  Helvetica: 'Helvetica',
  HelveticaBold: 'Helvetica-Bold',
};

const clamp = (value) => {
  if (Number.isNaN(value) || !Number.isFinite(value)) {
    return 0;
  }
  if (value < 0) return 0;
  if (value > 1) return 1;
  return value;
};

const rgb = (r, g, b) => ({
  r: clamp(r),
  g: clamp(g),
  b: clamp(b),
});

module.exports = {
  PDFDocument,
  StandardFonts,
  rgb,
};
